import time
import board
import digitalio
import rotaryio
import usb_hid
from adafruit_hid.keyboard import Keyboard
from adafruit_hid.keycode import Keycode
from adafruit_hid.consumer_control import ConsumerControl
from adafruit_hid.consumer_control_code import ConsumerControlCode

kbd = Keyboard(usb_hid.devices)
cc = ConsumerControl(usb_hid.devices)

button_config = [
    (board.D26, Keycode.F13),
    (board.D27, Keycode.F14),
    (board.D28, Keycode.F15),
    (board.D29, Keycode.F16),
    (board.D6,  Keycode.F17),
    (board.D7,  Keycode.F18),
    (board.D0,  Keycode.F19),
    (board.D1,  Keycode.F20),
    (board.D2,  Keycode.F21)
]

buttons = []
for pin, key in button_config:
    btn = digitalio.DigitalInOut(pin)
    btn.direction = digitalio.Direction.INPUT
    btn.pull = digitalio.Pull.UP
    buttons.append({'obj': btn, 'key': key, 'state': True})

encoder = rotaryio.IncrementalEncoder(board.D3, board.D4)
last_position = encoder.position

while True:
    for i, button in enumerate(buttons):
        current_state = button['obj'].value
        
        if current_state == False and button['state'] == True:
            if button['key'] is not None:
                kbd.press(button['key'])
            button['state'] = False

        elif current_state == True and button['state'] == False:
            if button['key'] is not None:
                kbd.release(button['key'])
            button['state'] = True

    current_position = encoder.position
    position_change = current_position - last_position
    
    if position_change > 0:
        cc.send(ConsumerControlCode.VOLUME_INCREMENT)
    elif position_change < 0:
        cc.send(ConsumerControlCode.VOLUME_DECREMENT)
    
    last_position = current_position

    time.sleep(0.01)
